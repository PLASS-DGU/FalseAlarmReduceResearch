11/04/2022 14:33:50 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:03:19 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:08:36 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:08:54 - INFO - __main__ -   ***** Running training *****
11/04/2022 15:08:54 - INFO - __main__ -     Num examples = 11238
11/04/2022 15:08:54 - INFO - __main__ -     Num Epochs = 10
11/04/2022 15:08:54 - INFO - __main__ -     Total train batch size = = 8
11/04/2022 15:13:04 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:13:22 - INFO - __main__ -   ***** Running training *****
11/04/2022 15:13:22 - INFO - __main__ -     Num examples = 11238
11/04/2022 15:13:22 - INFO - __main__ -     Num Epochs = 10
11/04/2022 15:13:22 - INFO - __main__ -     Total train batch size = = 8
11/04/2022 15:13:22 - INFO - __main__ -     Training epochs: 0
11/04/2022 15:14:13 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:14:31 - INFO - __main__ -   ***** Running training *****
11/04/2022 15:14:31 - INFO - __main__ -     Num examples = 11238
11/04/2022 15:14:31 - INFO - __main__ -     Num Epochs = 10
11/04/2022 15:14:31 - INFO - __main__ -     Total train batch size = = 8
11/04/2022 15:14:31 - INFO - __main__ -     Training epochs: 0
11/04/2022 15:15:50 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:16:07 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:22:15 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:22:32 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:34:32 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:34:49 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:36:28 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:36:45 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:37:13 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:37:30 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:38:55 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:39:12 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:39:52 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:40:08 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:43:19 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:43:36 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:49:25 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:49:43 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:50:15 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:50:32 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:50:34 - INFO - __main__ -   val_sample {'content_code': [['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                  ', 'static void goodG2B()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '                                                                          ', '    strcpy(data, "fixedstringtest");', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '                                                  ', 'static void goodB2G()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                           ', '    fprintf(stdout, "%s\\n", data);', '}', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_good()', '{', '    goodG2B();', '    goodB2G();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', ''], ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                                                 ', 'static void goodB2G1()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5!=5)', '    {', '                                                                          ', '        printLine("Benign, fixed string");', '    }', '    else', '    {', '                                                                               ', '        fprintf(stdout, "%s\\n", data);', '    }', '}', '', '                                                                                      ', 'static void goodB2G2()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5==5)', '    {', '                                                                               ', '        fprintf(stdout, "%s\\n", data);', '    }', '}', '', '                                                                                ', 'static void goodG2B1()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5!=5)', '    {', '                                                                          ', '        printLine("Benign, fixed string");', '    }', '    else', '    {', '                                                                              ', '        strcpy(data, "fixedstringtest");', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', '                                                                                     ', 'static void goodG2B2()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '                                                                              ', '        strcpy(data, "fixedstringtest");', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_good()', '{', '    goodB2G1();', '    goodB2G2();', '    goodG2B1();', '    goodG2B2();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', '']], 'content_remove_cmt': [['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                  ', 'static void goodG2B()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '                                                                          ', '    strcpy(data, "fixedstringtest");', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '                                                  ', 'static void goodB2G()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                           ', '    fprintf(stdout, "%s\\n", data);', '}', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_good()', '{', '    goodG2B();', '    goodB2G();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', ''], ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                                                 ', 'static void goodB2G1()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5!=5)', '    {', '                                                                          ', '        printLine("Benign, fixed string");', '    }', '    else', '    {', '                                                                               ', '        fprintf(stdout, "%s\\n", data);', '    }', '}', '', '                                                                                      ', 'static void goodB2G2()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5==5)', '    {', '                                                                               ', '        fprintf(stdout, "%s\\n", data);', '    }', '}', '', '                                                                                ', 'static void goodG2B1()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5!=5)', '    {', '                                                                          ', '        printLine("Benign, fixed string");', '    }', '    else', '    {', '                                                                              ', '        strcpy(data, "fixedstringtest");', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', '                                                                                     ', 'static void goodG2B2()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '                                                                              ', '        strcpy(data, "fixedstringtest");', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', 'void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_good()', '{', '    goodB2G1();', '    goodB2G2();', '    goodG2B1();', '    goodG2B2();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', '']], 'content_final': [['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void function_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                  ', 'static void goodG2B()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '                                                                          ', '    strcpy(data, "fixedstringtest");', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '                                                  ', 'static void goodB2G()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                           ', '    fprintf(stdout, "%s\\n", data);', '}', '', 'void function_good()', '{', '    goodG2B();', '    goodB2G();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    function_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    function_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', ''], ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void function_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                                                 ', 'static void goodB2G1()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5!=5)', '    {', '                                                                          ', '        printLine("Benign, fixed string");', '    }', '    else', '    {', '                                                                               ', '        fprintf(stdout, "%s\\n", data);', '    }', '}', '', '                                                                                      ', 'static void goodB2G2()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '        {', '#ifdef _WIN32', '            WSADATA wsaData;', '            int wsaDataInit = 0;', '#endif', '            int recvResult;', '            struct sockaddr_in service;', '            char *replace;', '            SOCKET connectSocket = INVALID_SOCKET;', '            size_t dataLen = strlen(data);', '            do', '            {', '#ifdef _WIN32', '                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '                {', '                    break;', '                }', '                wsaDataInit = 1;', '#endif', '                                                                      ', '                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '                if (connectSocket == INVALID_SOCKET)', '                {', '                    break;', '                }', '                memset(&service, 0, sizeof(service));', '                service.sin_family = AF_INET;', '                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '                service.sin_port = htons(TCP_PORT);', '                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '                {', '                    break;', '                }', '                /* Abort on error or the connection was closed, make sure to recv one', '                 * less char than is in the recv_buf in order to append a terminator */', '                                                                 ', '                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '                if (recvResult == SOCKET_ERROR || recvResult == 0)', '                {', '                    break;', '                }', '                                            ', "                data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                    ', "                replace = strchr(data, '\\r');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', "                replace = strchr(data, '\\n');", '                if (replace)', '                {', "                    *replace = '\\0';", '                }', '            }', '            while (0);', '            if (connectSocket != INVALID_SOCKET)', '            {', '                CLOSE_SOCKET(connectSocket);', '            }', '#ifdef _WIN32', '            if (wsaDataInit)', '            {', '                WSACleanup();', '            }', '#endif', '        }', '    }', '    if(5==5)', '    {', '                                                                               ', '        fprintf(stdout, "%s\\n", data);', '    }', '}', '', '                                                                                ', 'static void goodG2B1()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5!=5)', '    {', '                                                                          ', '        printLine("Benign, fixed string");', '    }', '    else', '    {', '                                                                              ', '        strcpy(data, "fixedstringtest");', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', '                                                                                     ', 'static void goodG2B2()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    if(5==5)', '    {', '                                                                              ', '        strcpy(data, "fixedstringtest");', '    }', '    if(5==5)', '    {', '                                                                                                       ', '        fprintf(stdout, data);', '    }', '}', '', 'void function_good()', '{', '    goodB2G1();', '    goodB2G2();', '    goodG2B1();', '    goodG2B2();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    function_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    function_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', '']], 'line_error': [119, 124], 'error_type': [9, 9], 'input_ids': [[0, 10431, 47209, 22, 47717, 1215, 21959, 11173, 4, 298, 113, 10431, 1594, 1187, 4550, 18134, 28974, 2881, 10431, 47209, 28696, 605, 24262, 4, 298, 15698, 10431, 49741, 10431, 1594, 9232, 18134, 28974, 2881, 10431, 47209, 28696, 605, 1344, 3343, 176, 4, 298, 15698, 10431, 47209, 28696, 47748, 4, 298, 15698, 10431, 47209, 28696, 27555, 4, 298, 15698, 10431, 4862, 1073, 1916, 1129, 1640, 34748, 6, 22, 12240, 176, 1215, 2881, 8070, 10431, 47634, 5289, 7949, 1215, 104, 13181, 3935, 14454, 31629, 10431, 44617, 10431, 47209, 28696, 43103, 73, 41817, 4, 298, 15698, 10431, 47209, 28696, 43103, 73, 48154, 4, 298, 15698, 10431, 47209, 28696, 4135, 28430, 73, 179, 4, 298, 15698, 10431, 47209, 28696, 11230, 102, 73, 28430, 4, 298, 15698, 10431, 47209, 28696, 879, 661, 417, 4, 298, 15698, 10431, 47634, 2808, 39766, 2688, 1215, 104, 13181, 3935, 111, 134, 10431, 47634, 208, 13181, 3935, 1215, 46734, 111, 134, 10431, 47634, 5289, 7949, 1215, 104, 13181, 3935, 593, 10431, 47634, 208, 13181, 3935, 6979, 10431, 49741, 10431, 47634, 42113, 1215, 20275, 974, 33279, 10431, 47634, 6442, 1215, 2606, 10644, 12147, 22, 24174, 4, 288, 4, 288, 4, 134, 113, 10431, 1594, 1187, 4550, 23765, 2068, 387, 2606, 47908, 5043, 1215, 10999, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 13691, 2606, 25912, 885, 11146, 30383, 131, 2544, 885, 11146, 30383, 49368, 5457, 321, 131, 10431, 49741, 2544, 3872, 705, 48136, 131, 2, 25384, 37390, 49439, 1215, 179, 544, 131, 24262, 1009, 44654, 131, 104, 13181, 3935, 4686, 49019, 5457, 2808, 39766, 2688, 1215, 104, 13181, 3935, 131, 10799, 1215, 90, 414, 45280, 5457, 7031, 8476, 1640, 23687, 4397, 5016, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 771, 3603, 33724, 658, 1640, 5273, 530, 15251, 11200, 1640, 176, 6, 176, 238, 359, 605, 11146, 30383, 43, 49333, 8228, 1215, 46734, 43, 45152, 10339, 131, 24303, 605, 11146, 30383, 49368, 5457, 112, 131, 10431, 49741, 24501, 49019, 5457, 37062, 1640, 8573, 1215, 2444, 3935, 6, 208, 13181, 1215, 4014, 28057, 6, 6442, 4454, 33770, 1215, 6078, 510, 4397, 1594, 36, 24501, 49019, 45994, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 10339, 131, 24303, 25683, 8738, 49763, 11131, 6, 321, 6, 49907, 1640, 11131, 48749, 11131, 4, 20338, 1215, 12368, 5457, 17491, 1215, 2444, 3935, 131, 11131, 4, 20338, 1215, 49439, 4, 29, 1215, 49439, 5457, 11, 594, 1215, 49439, 1640, 3808, 1215, 2606, 10644, 12147, 4397, 11131, 4, 20338, 1215, 3427, 5457, 1368, 38550, 1640, 6078, 510, 1215, 20275, 4397, 1594, 36, 24501, 1640, 24501, 49019, 6, 36, 25384, 37390, 49439, 44431, 947, 11131, 6, 49907, 1640, 11131, 35122, 45994, 208, 13181, 3935, 1215, 46734, 43, 45152, 10339, 131, 24303, 49051, 2060, 2723, 15, 5849, 50, 5, 2748, 21, 1367, 6, 146, 686, 7, 3872, 705, 65, 3226, 540, 16224, 87, 16, 11, 5, 3872, 705, 1215, 48939, 11, 645, 7, 40462, 10, 19022, 2630, 48404, 13139, 705, 48136, 5457, 3872, 705, 1640, 24501, 49019, 6, 36, 24262, 1009, 21704, 23687, 2055, 414, 45280, 238, 49907, 1640, 24262, 43, 1009, 36, 1866, 111, 414, 45280, 111, 112, 238, 321, 4397, 1594, 36, 13139, 705, 48136, 45994, 208, 13181, 3935, 1215, 46734, 45056, 3872, 705, 48136, 45994, 321, 43, 45152, 10339, 131, 24303, 23687, 10975, 23687, 45280, 2055, 3872, 705, 48136, 1589, 49907, 1640, 24262, 46077, 5457, 128, 37457, 288, 23500, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 338, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 282, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 24303, 20235, 36, 288, 4397, 1594, 36, 24501, 49019, 49333, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 13898, 1215, 104, 13181, 3935, 1640, 24501, 49019, 4397, 24303, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 605, 11146, 30383, 49368, 43, 45152, 13691, 2562, 21926, 658, 47006, 24303, 10431, 49741, 24303, 506, 49775, 1640, 47717, 995, 6, 414, 4397, 24303, 10431, 49741, 10431, 1594, 1187, 4550, 23765, 2068, 14740, 7111, 42653, 13842, 205, 534, 176, 387, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 6031, 438, 17163, 1640, 23687, 6, 22, 43713, 20951, 21959, 45751, 506, 49775, 1640, 47717, 995, 6, 414, 4397, 24303, 42653, 13842, 205, 387, 176, 534, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 13691, 2606, 25912, 885, 11146, 30383, 131, 2544, 885, 11146, 30383, 49368, 5457, 321, 131, 10431, 49741, 2544, 3872, 705, 48136, 131, 25384, 37390, 49439, 1215, 179, 544, 131, 24262, 1009, 44654, 131, 104, 13181, 3935, 4686, 49019, 5457, 2808, 39766, 2688, 1215, 104, 13181, 3935, 131, 10799, 1215, 90, 414, 45280, 5457, 7031, 8476, 1640, 23687, 4397, 5016, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 771, 3603, 33724, 658, 1640, 5273, 530, 15251, 11200, 1640, 176, 6, 176, 238, 359, 605, 11146, 30383, 43, 49333, 8228, 1215, 46734, 43, 45152, 10339, 131, 24303, 605, 11146, 30383, 49368, 5457, 112, 131, 10431, 49741, 24501, 49019, 5457, 37062, 1640, 8573, 1215, 2444, 3935, 6, 208, 13181, 1215, 4014, 28057, 6, 6442, 4454, 33770, 1215, 6078, 510, 4397, 1594, 36, 24501, 49019, 45994, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 10339, 131, 24303, 25683, 8738, 49763, 11131, 6, 321, 6, 49907, 1640, 11131, 48749, 11131, 4, 20338, 1215, 12368, 5457, 17491, 1215, 2444, 3935, 131, 11131, 4, 20338, 1215, 49439, 4, 29, 1215, 49439, 5457, 11, 594, 1215, 49439, 1640, 3808, 1215, 2606, 10644, 12147, 4397, 11131, 4, 20338, 1215, 3427, 5457, 1368, 38550, 1640, 6078, 510, 1215, 20275, 4397, 1594, 36, 24501, 1640, 24501, 49019, 6, 36, 25384, 37390, 49439, 44431, 947, 11131, 6, 49907, 1640, 11131, 35122, 45994, 208, 13181, 3935, 1215, 46734, 43, 45152, 10339, 131, 24303, 49051, 2060, 2723, 15, 5849, 50, 5, 2748, 21, 1367, 6, 146, 686, 7, 3872, 705, 65, 3226, 540, 16224, 87, 16, 11, 5, 3872, 705, 1215, 48939, 11, 645, 7, 40462, 10, 19022, 2630, 48404, 13139, 705, 48136, 5457, 3872, 705, 1640, 24501, 49019, 6, 36, 24262, 1009, 21704, 23687, 2055, 414, 45280, 238, 49907, 1640, 24262, 43, 1009, 36, 1866, 111, 414, 45280, 111, 112, 238, 321, 4397, 1594, 36, 13139, 705, 48136, 45994, 208, 13181, 3935, 1215, 46734, 45056, 3872, 705, 48136, 45994, 321, 43, 45152, 10339, 131, 24303, 23687, 10975, 23687, 45280, 2055, 3872, 705, 48136, 1589, 49907, 1640, 24262, 46077, 5457, 128, 37457, 288, 23500, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 338, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 282, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 24303, 20235, 36, 288, 4397, 1594, 36, 24501, 49019, 49333, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 13898, 1215, 104, 13181, 3935, 1640, 24501, 49019, 4397, 24303, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 605, 11146, 30383, 49368, 43, 45152, 13691, 2562, 21926, 658, 47006, 24303, 10431, 49741, 24303, 506, 49775, 1640, 47717, 995, 6, 49608, 29, 37457, 282, 1297, 414, 4397, 24303, 47908, 5043, 1215, 8396, 43048, 45152, 8396, 534, 176, 387, 47006, 8396, 387, 176, 534, 47006, 24303, 10431, 49741, 49051, 4421, 16, 5, 1049, 49123, 85, 16, 129, 341, 77, 745, 42, 1296, 11173, 15, 2629, 308, 13, 3044, 50, 13, 745, 10, 32771, 7, 304, 11, 3044, 32771, 31116, 3270, 4, 85, 16, 45, 341, 77, 33506, 70, 5, 1296, 28162, 25, 65, 40545, 6, 61, 16, 141, 1300, 3260, 1966, 3270, 32, 4776, 4, 48404, 10431, 1594, 9232, 46393, 26674, 2444, 2544, 1049, 1640, 2544, 29480, 438, 6, 16224, 1009, 29480, 705, 10975, 45587, 45152, 29, 22103, 1640, 36, 49418, 43, 958, 1640, 49728, 43, 47162, 10431, 1594, 1187, 4550, 23765, 2068, 14740, 7111, 17265, 18997, 46469, 45424, 205, 43048, 27223, 4397, 35435, 1215, 8396, 47006, 17265, 18997, 46469, 34027, 6555, 205, 43048, 45751, 10431, 49741, 10431, 1594, 1187, 4550, 23765, 2068, 387, 2606, 17265, 18997, 46469, 45424, 1099, 43048, 27223, 4397, 35435, 1215, 10999, 47006, 17265, 18997, 46469, 34027, 6555, 1099, 43048, 45751, 10431, 49741, 30921, 321, 131, 24303, 10431, 49741], [0, 10431, 47209, 22, 47717, 1215, 21959, 11173, 4, 298, 113, 10431, 1594, 1187, 4550, 18134, 28974, 2881, 10431, 47209, 28696, 605, 24262, 4, 298, 15698, 10431, 49741, 10431, 1594, 9232, 18134, 28974, 2881, 10431, 47209, 28696, 605, 1344, 3343, 176, 4, 298, 15698, 10431, 47209, 28696, 47748, 4, 298, 15698, 10431, 47209, 28696, 27555, 4, 298, 15698, 10431, 4862, 1073, 1916, 1129, 1640, 34748, 6, 22, 12240, 176, 1215, 2881, 8070, 10431, 47634, 5289, 7949, 1215, 104, 13181, 3935, 14454, 31629, 10431, 44617, 10431, 47209, 28696, 43103, 73, 41817, 4, 298, 15698, 10431, 47209, 28696, 43103, 73, 48154, 4, 298, 15698, 10431, 47209, 28696, 4135, 28430, 73, 179, 4, 298, 15698, 10431, 47209, 28696, 11230, 102, 73, 28430, 4, 298, 15698, 10431, 47209, 28696, 879, 661, 417, 4, 298, 15698, 10431, 47634, 2808, 39766, 2688, 1215, 104, 13181, 3935, 111, 134, 10431, 47634, 208, 13181, 3935, 1215, 46734, 111, 134, 10431, 47634, 5289, 7949, 1215, 104, 13181, 3935, 593, 10431, 47634, 208, 13181, 3935, 6979, 10431, 49741, 10431, 47634, 42113, 1215, 20275, 974, 33279, 10431, 47634, 6442, 1215, 2606, 10644, 12147, 22, 24174, 4, 288, 4, 288, 4, 134, 113, 10431, 1594, 1187, 4550, 23765, 2068, 387, 2606, 47908, 5043, 1215, 10999, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 1594, 1640, 245, 43292, 245, 43, 45152, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 13691, 2606, 25912, 885, 11146, 30383, 131, 2544, 885, 11146, 30383, 49368, 5457, 321, 131, 10431, 49741, 2544, 3872, 705, 48136, 131, 25384, 37390, 49439, 1215, 179, 544, 131, 24262, 1009, 44654, 131, 104, 13181, 3935, 4686, 49019, 5457, 2808, 39766, 2688, 1215, 104, 13181, 3935, 131, 10799, 1215, 90, 414, 45280, 5457, 7031, 8476, 1640, 23687, 4397, 5016, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 771, 3603, 33724, 658, 1640, 5273, 530, 15251, 11200, 1640, 176, 6, 176, 238, 359, 605, 11146, 30383, 43, 49333, 8228, 1215, 46734, 43, 45152, 10339, 131, 24303, 605, 11146, 30383, 49368, 5457, 112, 131, 10431, 49741, 24501, 49019, 5457, 37062, 1640, 8573, 1215, 2444, 3935, 6, 208, 13181, 1215, 4014, 28057, 6, 6442, 4454, 33770, 1215, 6078, 510, 4397, 1594, 36, 24501, 49019, 45994, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 2, 10339, 131, 24303, 25683, 8738, 49763, 11131, 6, 321, 6, 49907, 1640, 11131, 48749, 11131, 4, 20338, 1215, 12368, 5457, 17491, 1215, 2444, 3935, 131, 11131, 4, 20338, 1215, 49439, 4, 29, 1215, 49439, 5457, 11, 594, 1215, 49439, 1640, 3808, 1215, 2606, 10644, 12147, 4397, 11131, 4, 20338, 1215, 3427, 5457, 1368, 38550, 1640, 6078, 510, 1215, 20275, 4397, 1594, 36, 24501, 1640, 24501, 49019, 6, 36, 25384, 37390, 49439, 44431, 947, 11131, 6, 49907, 1640, 11131, 35122, 45994, 208, 13181, 3935, 1215, 46734, 43, 45152, 10339, 131, 24303, 49051, 2060, 2723, 15, 5849, 50, 5, 2748, 21, 1367, 6, 146, 686, 7, 3872, 705, 65, 3226, 540, 16224, 87, 16, 11, 5, 3872, 705, 1215, 48939, 11, 645, 7, 40462, 10, 19022, 2630, 48404, 13139, 705, 48136, 5457, 3872, 705, 1640, 24501, 49019, 6, 36, 24262, 1009, 21704, 23687, 2055, 414, 45280, 238, 49907, 1640, 24262, 43, 1009, 36, 1866, 111, 414, 45280, 111, 112, 238, 321, 4397, 1594, 36, 13139, 705, 48136, 45994, 208, 13181, 3935, 1215, 46734, 45056, 3872, 705, 48136, 45994, 321, 43, 45152, 10339, 131, 24303, 23687, 10975, 23687, 45280, 2055, 3872, 705, 48136, 1589, 49907, 1640, 24262, 46077, 5457, 128, 37457, 288, 23500, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 338, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 282, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 24303, 20235, 36, 288, 4397, 1594, 36, 24501, 49019, 49333, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 13898, 1215, 104, 13181, 3935, 1640, 24501, 49019, 4397, 24303, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 605, 11146, 30383, 49368, 43, 45152, 13691, 2562, 21926, 658, 47006, 24303, 10431, 49741, 24303, 24303, 1594, 1640, 245, 43292, 245, 43, 45152, 506, 49775, 1640, 47717, 995, 6, 414, 4397, 24303, 24303, 10431, 49741, 10431, 1594, 1187, 4550, 23765, 2068, 14740, 7111, 42653, 13842, 205, 387, 176, 534, 134, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 1594, 1640, 245, 43292, 245, 43, 45152, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 13691, 2606, 25912, 885, 11146, 30383, 131, 2544, 885, 11146, 30383, 49368, 5457, 321, 131, 10431, 49741, 2544, 3872, 705, 48136, 131, 25384, 37390, 49439, 1215, 179, 544, 131, 24262, 1009, 44654, 131, 104, 13181, 3935, 4686, 49019, 5457, 2808, 39766, 2688, 1215, 104, 13181, 3935, 131, 10799, 1215, 90, 414, 45280, 5457, 7031, 8476, 1640, 23687, 4397, 5016, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 771, 3603, 33724, 658, 1640, 5273, 530, 15251, 11200, 1640, 176, 6, 176, 238, 359, 605, 11146, 30383, 43, 49333, 8228, 1215, 46734, 43, 45152, 10339, 131, 24303, 605, 11146, 30383, 49368, 5457, 112, 131, 10431, 49741, 24501, 49019, 5457, 37062, 1640, 8573, 1215, 2444, 3935, 6, 208, 13181, 1215, 4014, 28057, 6, 6442, 4454, 33770, 1215, 6078, 510, 4397, 1594, 36, 24501, 49019, 45994, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 10339, 131, 24303, 25683, 8738, 49763, 11131, 6, 321, 6, 49907, 1640, 11131, 48749, 11131, 4, 20338, 1215, 12368, 5457, 17491, 1215, 2444, 3935, 131, 11131, 4, 20338, 1215, 49439, 4, 29, 1215, 49439, 5457, 11, 594, 1215, 49439, 1640, 3808, 1215, 2606, 10644, 12147, 4397, 11131, 4, 20338, 1215, 3427, 5457, 1368, 38550, 1640, 6078, 510, 1215, 20275, 4397, 1594, 36, 24501, 1640, 24501, 49019, 6, 36, 25384, 37390, 49439, 44431, 947, 11131, 6, 49907, 1640, 11131, 35122, 45994, 208, 13181, 3935, 1215, 46734, 43, 45152, 10339, 131, 24303, 49051, 2060, 2723, 15, 5849, 50, 5, 2748, 21, 1367, 6, 146, 686, 7, 3872, 705, 65, 3226, 540, 16224, 87, 16, 11, 5, 3872, 705, 1215, 48939, 11, 645, 7, 40462, 10, 19022, 2630, 48404, 13139, 705, 48136, 5457, 3872, 705, 1640, 24501, 49019, 6, 36, 24262, 1009, 21704, 23687, 2055, 414, 45280, 238, 49907, 1640, 24262, 43, 1009, 36, 1866, 111, 414, 45280, 111, 112, 238, 321, 4397, 1594, 36, 13139, 705, 48136, 45994, 208, 13181, 3935, 1215, 46734, 45056, 3872, 705, 48136, 45994, 321, 43, 45152, 10339, 131, 24303, 23687, 10975, 23687, 45280, 2055, 3872, 705, 48136, 1589, 49907, 1640, 24262, 46077, 5457, 128, 37457, 288, 23500, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 338, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 282, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 24303, 20235, 36, 288, 4397, 1594, 36, 24501, 49019, 49333, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 13898, 1215, 104, 13181, 3935, 1640, 24501, 49019, 4397, 24303, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 605, 11146, 30383, 49368, 43, 45152, 13691, 2562, 21926, 658, 47006, 24303, 10431, 49741, 24303, 24303, 1594, 1640, 245, 328, 5214, 245, 43, 45152, 17265, 18997, 46469, 17521, 4932, 6, 4460, 6755, 45751, 24303, 44617, 45152, 506, 49775, 1640, 47717, 995, 6, 49608, 29, 37457, 282, 1297, 414, 4397, 24303, 24303, 42653, 13842, 205, 387, 176, 534, 176, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 1594, 1640, 245, 43292, 245, 43, 45152, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 13691, 2606, 25912, 885, 11146, 30383, 131, 2544, 885, 11146, 30383, 49368, 5457, 321, 131, 10431, 49741, 2544, 3872, 705, 48136, 131, 25384, 37390, 49439, 1215, 179, 544, 131, 24262, 1009, 44654, 131, 104, 13181, 3935, 4686, 49019, 5457, 2808, 39766, 2688, 1215, 104, 13181, 3935, 131, 10799, 1215, 90, 414, 45280, 5457, 7031, 8476, 1640, 23687, 4397, 5016, 45152, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 771, 3603, 33724, 658, 1640, 5273, 530, 15251, 11200, 1640, 176, 6, 176, 238, 359, 605, 11146, 30383, 43, 49333, 8228, 1215, 46734, 43, 45152, 10339, 131, 24303, 605, 11146, 30383, 49368, 5457, 112, 131, 10431, 49741, 24501, 49019, 5457, 37062, 1640, 8573, 1215, 2444, 3935, 6, 208, 13181, 1215, 4014, 28057, 6, 6442, 4454, 33770, 1215, 6078, 510, 4397, 1594, 36, 24501, 49019, 45994, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 10339, 131, 24303, 25683, 8738, 49763, 11131, 6, 321, 6, 49907, 1640, 11131, 48749, 11131, 4, 20338, 1215, 12368, 5457, 17491, 1215, 2444, 3935, 131, 11131, 4, 20338, 1215, 49439, 4, 29, 1215, 49439, 5457, 11, 594, 1215, 49439, 1640, 3808, 1215, 2606, 10644, 12147, 4397, 11131, 4, 20338, 1215, 3427, 5457, 1368, 38550, 1640, 6078, 510, 1215, 20275, 4397, 1594, 36, 24501, 1640, 24501, 49019, 6, 36, 25384, 37390, 49439, 44431, 947, 11131, 6, 49907, 1640, 11131, 35122, 45994, 208, 13181, 3935, 1215, 46734, 43, 45152, 10339, 131, 24303, 49051, 2060, 2723, 15, 5849, 50, 5, 2748, 21, 1367, 6, 146, 686, 7, 3872, 705, 65, 3226, 540, 16224, 87, 16, 11, 5, 3872, 705, 1215, 48939, 11, 645, 7, 40462, 10, 19022, 2630, 48404, 13139, 705, 48136, 5457, 3872, 705, 1640, 24501, 49019, 6, 36, 24262, 1009, 21704, 23687, 2055, 414, 45280, 238, 49907, 1640, 24262, 43, 1009, 36, 1866, 111, 414, 45280, 111, 112, 238, 321, 4397, 1594, 36, 13139, 705, 48136, 45994, 208, 13181, 3935, 1215, 46734, 45056, 3872, 705, 48136, 45994, 321, 43, 45152, 10339, 131, 24303, 23687, 10975, 23687, 45280, 2055, 3872, 705, 48136, 1589, 49907, 1640, 24262, 46077, 5457, 128, 37457, 288, 23500, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 338, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 44654, 5457, 7031, 611, 338, 1640, 23687, 6, 128, 37457, 282, 47033, 1594, 36, 44654, 43, 45152, 3226, 44654, 5457, 128, 37457, 288, 23500, 24303, 24303, 20235, 36, 288, 4397, 1594, 36, 24501, 49019, 49333, 2808, 39766, 2688, 1215, 104, 13181, 3935, 43, 45152, 13898, 1215, 104, 13181, 3935, 1640, 24501, 49019, 4397, 24303, 10431, 1594, 9232, 18134, 28974, 2881, 1594, 36, 605, 11146, 30383, 49368, 43, 45152, 13691, 2562, 21926, 658, 47006, 24303, 10431, 49741, 24303, 24303, 1594, 1640, 245, 43292, 245, 43, 45152, 506, 49775, 1640, 47717, 995, 6, 49608, 29, 37457, 282, 1297, 414, 4397, 24303, 24303, 42653, 13842, 205, 534, 176, 387, 134, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 1594, 1640, 245, 328, 5214, 245, 43, 45152, 17265, 18997, 46469, 17521, 4932, 6, 4460, 6755, 45751, 24303, 44617, 45152, 6031, 438, 17163, 1640, 23687, 6, 22, 43713, 20951, 21959, 45751, 24303, 1594, 1640, 245, 43292, 245, 43, 45152, 506, 49775, 1640, 47717, 995, 6, 414, 4397, 24303, 24303, 42653, 13842, 205, 534, 176, 387, 176, 43048, 45152, 24262, 1009, 414, 131, 24262, 414, 49334, 10975, 1866, 742, 5457, 22, 25718, 23687, 5457, 414, 49334, 131, 1594, 1640, 245, 43292, 245, 43, 45152, 6031, 438, 17163, 1640, 23687, 6, 22, 43713, 20951, 21959, 45751, 24303, 1594, 1640, 245, 43292, 245, 43, 45152, 506, 49775, 1640, 47717, 995, 6, 414, 4397, 24303, 24303, 47908, 5043, 1215, 8396, 43048, 45152, 8396, 387, 176, 534, 134, 47006, 8396, 387, 176, 534, 176, 47006, 8396, 534, 176, 387, 134, 47006, 8396, 534, 176, 387, 176, 47006, 24303, 10431, 49741, 49051, 4421, 16, 5, 1049, 49123, 85, 16, 129, 341, 77, 745, 42, 1296, 11173, 15, 2629, 308, 13, 3044, 50, 13, 745, 10, 32771, 7, 304, 11, 3044, 32771, 31116, 3270, 4, 85, 16, 45, 341, 77, 33506, 70, 5, 1296, 28162, 25, 65, 40545, 6, 61, 16, 141, 1300, 3260, 1966, 3270, 32, 4776, 4, 48404, 10431, 1594, 9232, 46393, 26674, 2444, 2544, 1049, 1640, 2544, 29480, 438, 6, 16224, 1009, 29480, 705, 10975, 45587, 45152, 29, 22103, 1640, 36, 49418, 43, 958, 1640, 49728, 43, 47162, 10431, 1594, 1187, 4550, 23765, 2068, 14740, 7111, 17265, 18997, 46469, 45424, 205, 43048, 27223, 4397, 35435, 1215, 8396, 47006, 17265, 18997, 46469, 34027, 6555, 205, 43048, 45751, 10431, 49741, 10431, 1594, 1187, 4550, 23765, 2068, 387, 2606, 17265, 18997, 46469, 45424, 1099, 43048, 27223, 4397, 35435, 1215, 10999, 47006, 17265, 18997, 46469, 34027, 6555, 1099, 43048, 45751, 10431, 49741, 30921, 321, 131, 24303, 10431, 49741]], 'line_index': [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 40, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 44, 44, 45, 46, 46, 46, 46, 46, 46, 46, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 51, 51, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 59, 59, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 66, 66, 67, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70, 70, 70, 70, 71, 72, 72, 72, 72, 72, 72, 72, 73, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 76, 77, 77, 77, 77, 77, 77, 77, 78, 79, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 82, 83, 83, 83, 83, 83, 83, 83, 83, 83, 84, 85, 85, 85, 85, 85, 85, 86, 86, 86, 86, 86, 86, 86, 87, 88, 88, 88, 88, 88, 89, 90, 90, 91, 92, 92, 92, 92, 92, 92, 92, 92, 93, 94, 94, 95, 95, 95, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96, 96, 96, 97, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 103, 104, 104, 104, 104, 104, 104, 104, 105, 106, 106, 106, 106, 107, 107, 107, 107, 107, 107, 107, 107, 107, 108, 108, 108, 108, 108, 109, 110, 110, 110, 110, 110, 110, 111, 111, 111, 111, 111, 111, 111, 112, 112, 112, 112, 112, 112, 112, 112, 113, 113, 114, 114, 114, 114, 114, 115, 115, 115, 115, 115, 115, 115, 116, 116, 116, 116, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 119, 120, 121, 121, 121, 121, 121, 121, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 123, 124, 124, 125, 126, 126, 126, 126, 126, 126, 126, 127, 127, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 130, 131, 131, 132, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 138, 139, 139, 140, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 145, 146, 146, 147, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 151, 152, 152, 152, 152, 152, 152, 152, 153, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 155, 155, 155, 155, 156, 157, 157, 157, 157, 157, 157, 157, 158, 159, 160, 160, 160, 160, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 162, 163, 163, 163, 163, 163, 163, 163, 163, 163, 164, 165, 165, 165, 165, 165, 165, 166, 166, 166, 166, 166, 166, 166, 167, 168, 168, 168, 168, 168, 169, 170, 170, 171, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 173, 174, 174, 174, 174, 174, 175, 176, 176, 176, 176, 176, 177, 177, 177, 177, 177, 178, 179, 179, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 184, 184, 184, 184, 184, 184, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 186, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 188, 188, 188, 188, 188, 188, 188, 188, 189, 189, 189, 189, 189, 189, 189, 189, 190, 190, 190, 190, 191, 191, 191, 191, 191, 191, 191, 191, 192, 192, 193, 193, 193, 193, 193, 193, 193, 193, 194, 194, 194, 194, 194, 194, 194, 194, 195, 195, 195, 195, 196, 196, 196, 196, 196, 196, 196, 196, 197, 197, 198, 198, 198, 199, 200, 200], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 30, 31, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 42, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 45, 46, 46, 47, 48, 48, 48, 48, 48, 48, 48, 49, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 53, 53, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 61, 61, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 68, 68, 69, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 72, 72, 72, 73, 74, 74, 74, 74, 74, 74, 74, 75, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 77, 77, 77, 77, 78, 79, 79, 79, 79, 79, 79, 79, 80, 81, 82, 82, 82, 82, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 84, 85, 85, 85, 85, 85, 85, 85, 85, 85, 86, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 88, 88, 89, 90, 90, 90, 90, 90, 91, 92, 92, 93, 94, 95, 95, 95, 95, 95, 95, 96, 97, 97, 97, 97, 97, 97, 97, 97, 98, 99, 100, 100, 101, 101, 101, 101, 101, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 103, 104, 104, 104, 104, 105, 105, 105, 105, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 107, 108, 109, 110, 110, 110, 110, 110, 110, 111, 111, 111, 111, 111, 111, 111, 112, 112, 112, 112, 112, 112, 112, 112, 113, 113, 114, 114, 114, 114, 114, 115, 115, 115, 115, 115, 115, 115, 116, 116, 116, 116, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 119, 120, 121, 121, 121, 121, 121, 121, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 123, 124, 124, 125, 126, 126, 126, 126, 126, 126, 126, 127, 127, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 130, 131, 131, 132, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 138, 139, 139, 140, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 145, 146, 146, 147, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 151, 152, 152, 152, 152, 152, 152, 152, 153, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 155, 155, 155, 155, 156, 157, 157, 157, 157, 157, 157, 157, 158, 159, 160, 160, 160, 160, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 162, 163, 163, 163, 163, 163, 163, 163, 163, 163, 164, 165, 165, 165, 165, 165, 165, 166, 166, 166, 166, 166, 166, 166, 167, 168, 168, 168, 168, 168, 169, 170, 170, 171, 172, 173, 173, 173, 173, 173, 173, 173, 174, 175, 175, 175, 175, 175, 175, 175, 175, 175, 176, 177, 178, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 180, 181, 182, 182, 182, 182, 182, 182, 182, 182, 183, 184, 184, 184, 184, 185, 185, 185, 185, 185, 185, 185, 185, 185, 186, 186, 186, 186, 186, 187, 187, 187, 187, 187, 187, 188, 189, 190, 190, 190, 190, 190, 190, 191, 191, 191, 191, 191, 191, 191, 192, 192, 192, 192, 192, 192, 192, 192, 193, 193, 194, 194, 194, 194, 194, 195, 195, 195, 195, 195, 195, 195, 196, 196, 196, 196, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 199, 200, 201, 201, 201, 201, 201, 201, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 203, 204, 204, 205, 206, 206, 206, 206, 206, 206, 206, 207, 207, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 210, 211, 211, 212, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 218, 219, 219, 220, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 225, 226, 226, 227, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 230, 230, 230, 230, 231, 232, 232, 232, 232, 232, 232, 232, 233, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 235, 235, 235, 235, 236, 237, 237, 237, 237, 237, 237, 237, 238, 239, 240, 240, 240, 240, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 242, 243, 243, 243, 243, 243, 243, 243, 243, 243, 244, 245, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246, 246, 246, 247, 248, 248, 248, 248, 248, 249, 250, 250, 251, 252, 253, 253, 253, 253, 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 256, 257, 258, 258, 258, 258, 258, 258, 258, 258, 259, 260, 260, 260, 260, 261, 261, 261, 261, 261, 261, 261, 261, 261, 262, 262, 262, 262, 262, 263, 263, 263, 263, 263, 263, 263, 264, 265, 265, 265, 265, 265, 265, 265, 265, 265, 266, 267, 268, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 270, 271, 271, 271, 271, 271, 271, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 275, 276, 276, 276, 276, 276, 276, 276, 276, 277, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 282, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 285, 285, 285, 285, 285, 285, 286, 287, 287, 287, 287, 287, 287, 287, 287, 288, 289, 290, 290, 290, 290, 290, 291, 292, 292, 292, 292, 292, 292, 293, 293, 293, 293, 293, 293, 294, 294, 294, 294, 294, 294, 295, 295, 295, 295, 295, 295, 296, 297, 297, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 301, 301, 301, 301, 301, 301, 301, 301, 301, 301, 301, 301, 301, 302, 302, 302, 302, 302, 302, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 304, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 306, 306, 306, 306, 306, 306, 306, 306, 307, 307, 307, 307, 307, 307, 307, 307, 308, 308, 308, 308, 309, 309, 309, 309, 309, 309, 309, 309, 310, 310, 311, 311, 311, 311, 311, 311, 311, 311, 312, 312, 312, 312, 312, 312, 312, 312, 313, 313, 313, 313, 314, 314, 314, 314, 314, 314, 314, 314, 315, 315, 316, 316, 316, 317, 318, 318]], 'label_sentent': [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], 'content_view': [['#include "std_testcase.h"', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")', '#define CLOSE_SOCKET closesocket', '#else', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '#ifndef OMITBAD', 'void function_bad()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', 'fprintf(stdout, data);', '}', '#endif', '#ifndef OMITGOOD', 'static void goodG2B()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'strcpy(data, "fixedstringtest");', 'fprintf(stdout, data);', '}', 'static void goodB2G()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', 'fprintf(stdout, "%s\\n", data);', '}', 'void function_good()', '{', 'goodG2B();', 'goodB2G();', '}', '#endif', '/* Below is the main(). It is only used when building this testcase on', 'its own for testing or for building a binary to use in testing binary', 'analysis tools. It is not used when compiling all the testcases as one', 'application, which is how source code analysis tools are tested. */', '#ifdef INCLUDEMAIN', 'int main(int argc, char * argv[])', '{', 'srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', 'printLine("Calling good()...");', 'function_good();', 'printLine("Finished good()");', '#endif', '#ifndef OMITBAD', 'printLine("Calling bad()...");', 'function_bad();', 'printLine("Finished bad()");', '#endif', 'return 0;', '}', '#endif'], ['#include "std_testcase.h"', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")', '#define CLOSE_SOCKET closesocket', '#else', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '#ifndef OMITBAD', 'void function_bad()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'if(5==5)', '{', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', '}', 'if(5==5)', '{', 'fprintf(stdout, data);', '}', '}', '#endif', '#ifndef OMITGOOD', 'static void goodB2G1()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'if(5==5)', '{', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', '}', 'if(5!=5)', '{', 'printLine("Benign, fixed string");', '}', 'else', '{', 'fprintf(stdout, "%s\\n", data);', '}', '}', 'static void goodB2G2()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'if(5==5)', '{', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', '}', 'if(5==5)', '{', 'fprintf(stdout, "%s\\n", data);', '}', '}', 'static void goodG2B1()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'if(5!=5)', '{', 'printLine("Benign, fixed string");', '}', 'else', '{', 'strcpy(data, "fixedstringtest");', '}', 'if(5==5)', '{', 'fprintf(stdout, data);', '}', '}', 'static void goodG2B2()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'if(5==5)', '{', 'strcpy(data, "fixedstringtest");', '}', 'if(5==5)', '{', 'fprintf(stdout, data);', '}', '}', 'void function_good()', '{', 'goodB2G1();', 'goodB2G2();', 'goodG2B1();', 'goodG2B2();', '}', '#endif', '/* Below is the main(). It is only used when building this testcase on', 'its own for testing or for building a binary to use in testing binary', 'analysis tools. It is not used when compiling all the testcases as one', 'application, which is how source code analysis tools are tested. */', '#ifdef INCLUDEMAIN', 'int main(int argc, char * argv[])', '{', 'srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', 'printLine("Calling good()...");', 'function_good();', 'printLine("Finished good()");', '#endif', '#ifndef OMITBAD', 'printLine("Calling bad()...");', 'function_bad();', 'printLine("Finished bad()");', '#endif', 'return 0;', '}', '#endif']], 'max_trix_sent': tensor([[[1., 0., 0.,  ..., 0., 0., 0.],
         [1., 0., 0.,  ..., 0., 0., 0.],
         [1., 0., 0.,  ..., 0., 0., 0.],
         ...,
         [0., 0., 0.,  ..., 0., 0., 0.],
         [0., 0., 0.,  ..., 0., 0., 0.],
         [0., 0., 0.,  ..., 0., 0., 0.]],

        [[1., 0., 0.,  ..., 0., 0., 0.],
         [1., 0., 0.,  ..., 0., 0., 0.],
         [1., 0., 0.,  ..., 0., 0., 0.],
         ...,
         [0., 0., 0.,  ..., 0., 0., 0.],
         [0., 0., 0.,  ..., 0., 0., 0.],
         [0., 0., 0.,  ..., 0., 0., 0.]]], device='cuda:0'), 'label_tensor': tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0]], device='cuda:0'), 'input_batch_ids': tensor([[    0, 10431, 47209,    22, 47717,  1215, 21959, 11173,     4,   298,
           113, 10431,  1594,  1187,  4550, 18134, 28974,  2881, 10431, 47209,
         28696,   605, 24262,     4,   298, 15698, 10431, 49741, 10431,  1594,
          9232, 18134, 28974,  2881, 10431, 47209, 28696,   605,  1344,  3343,
           176,     4,   298, 15698, 10431, 47209, 28696, 47748,     4,   298,
         15698, 10431, 47209, 28696, 27555,     4,   298, 15698, 10431,  4862,
          1073,  1916,  1129,  1640, 34748,     6,    22, 12240,   176,  1215,
          2881,  8070, 10431, 47634,  5289,  7949,  1215,   104, 13181,  3935,
         14454, 31629, 10431, 44617, 10431, 47209, 28696, 43103,    73, 41817,
             4,   298, 15698, 10431, 47209, 28696, 43103,    73, 48154,     4,
           298, 15698, 10431, 47209, 28696,  4135, 28430,    73,   179,     4,
           298, 15698, 10431, 47209, 28696, 11230,   102,    73, 28430,     4,
           298, 15698, 10431, 47209, 28696,   879,   661,   417,     4,   298,
         15698, 10431, 47634,  2808, 39766,  2688,  1215,   104, 13181,  3935,
           111,   134, 10431, 47634,   208, 13181,  3935,  1215, 46734,   111,
           134, 10431, 47634,  5289,  7949,  1215,   104, 13181,  3935,   593,
         10431, 47634,   208, 13181,  3935,  6979, 10431, 49741, 10431, 47634,
         42113,  1215, 20275,   974, 33279, 10431, 47634,  6442,  1215,  2606,
         10644, 12147,    22, 24174,     4,   288,     4,   288,     4,   134,
           113, 10431,  1594,  1187,  4550, 23765,  2068,   387,  2606, 47908,
          5043,  1215, 10999, 43048, 45152, 24262,  1009,   414,   131, 24262,
           414, 49334, 10975,  1866,   742,  5457,    22, 25718, 23687,  5457,
           414, 49334,   131, 45152, 10431,  1594,  9232, 18134, 28974,  2881,
         13691,  2606, 25912,   885, 11146, 30383,   131,  2544,   885, 11146,
         30383, 49368,  5457,   321,   131, 10431, 49741,  2544,  3872,   705,
         48136,   131,     2, 25384, 37390, 49439,  1215,   179,   544,   131,
         24262,  1009, 44654,   131,   104, 13181,  3935,  4686, 49019,  5457,
          2808, 39766,  2688,  1215,   104, 13181,  3935,   131, 10799,  1215,
            90,   414, 45280,  5457,  7031,  8476,  1640, 23687,  4397,  5016,
         45152, 10431,  1594,  9232, 18134, 28974,  2881,  1594,    36,   771,
          3603, 33724,   658,  1640,  5273,   530, 15251, 11200,  1640,   176,
             6,   176,   238,   359,   605, 11146, 30383,    43, 49333,  8228,
          1215, 46734,    43, 45152, 10339,   131, 24303,   605, 11146, 30383,
         49368,  5457,   112,   131, 10431, 49741, 24501, 49019,  5457, 37062,
          1640,  8573,  1215,  2444,  3935,     6,   208, 13181,  1215,  4014,
         28057,     6,  6442,  4454, 33770,  1215,  6078,   510,  4397,  1594,
            36, 24501, 49019, 45994,  2808, 39766,  2688,  1215,   104, 13181,
          3935,    43, 45152, 10339,   131, 24303, 25683,  8738, 49763, 11131,
             6,   321,     6, 49907,  1640, 11131, 48749, 11131,     4, 20338,
          1215, 12368,  5457, 17491,  1215,  2444,  3935,   131, 11131,     4,
         20338,  1215, 49439,     4,    29,  1215, 49439,  5457,    11,   594,
          1215, 49439,  1640,  3808,  1215,  2606, 10644, 12147,  4397, 11131,
             4, 20338,  1215,  3427,  5457,  1368, 38550,  1640,  6078,   510,
          1215, 20275,  4397,  1594,    36, 24501,  1640, 24501, 49019,     6,
            36, 25384, 37390, 49439, 44431,   947, 11131,     6, 49907,  1640,
         11131, 35122, 45994,   208, 13181,  3935,  1215, 46734,    43, 45152,
         10339,   131, 24303, 49051,  2060,  2723,    15,  5849,    50,     5,
          2748,    21,  1367,     6,   146,   686,     7,  3872,   705,    65,
          3226,   540, 16224,    87,    16,    11,     5,  3872,   705,  1215,
         48939,    11,   645,     7, 40462,    10, 19022,  2630, 48404, 13139],
        [    0, 10431, 47209,    22, 47717,  1215, 21959, 11173,     4,   298,
           113, 10431,  1594,  1187,  4550, 18134, 28974,  2881, 10431, 47209,
         28696,   605, 24262,     4,   298, 15698, 10431, 49741, 10431,  1594,
          9232, 18134, 28974,  2881, 10431, 47209, 28696,   605,  1344,  3343,
           176,     4,   298, 15698, 10431, 47209, 28696, 47748,     4,   298,
         15698, 10431, 47209, 28696, 27555,     4,   298, 15698, 10431,  4862,
          1073,  1916,  1129,  1640, 34748,     6,    22, 12240,   176,  1215,
          2881,  8070, 10431, 47634,  5289,  7949,  1215,   104, 13181,  3935,
         14454, 31629, 10431, 44617, 10431, 47209, 28696, 43103,    73, 41817,
             4,   298, 15698, 10431, 47209, 28696, 43103,    73, 48154,     4,
           298, 15698, 10431, 47209, 28696,  4135, 28430,    73,   179,     4,
           298, 15698, 10431, 47209, 28696, 11230,   102,    73, 28430,     4,
           298, 15698, 10431, 47209, 28696,   879,   661,   417,     4,   298,
         15698, 10431, 47634,  2808, 39766,  2688,  1215,   104, 13181,  3935,
           111,   134, 10431, 47634,   208, 13181,  3935,  1215, 46734,   111,
           134, 10431, 47634,  5289,  7949,  1215,   104, 13181,  3935,   593,
         10431, 47634,   208, 13181,  3935,  6979, 10431, 49741, 10431, 47634,
         42113,  1215, 20275,   974, 33279, 10431, 47634,  6442,  1215,  2606,
         10644, 12147,    22, 24174,     4,   288,     4,   288,     4,   134,
           113, 10431,  1594,  1187,  4550, 23765,  2068,   387,  2606, 47908,
          5043,  1215, 10999, 43048, 45152, 24262,  1009,   414,   131, 24262,
           414, 49334, 10975,  1866,   742,  5457,    22, 25718, 23687,  5457,
           414, 49334,   131,  1594,  1640,   245, 43292,   245,    43, 45152,
         45152, 10431,  1594,  9232, 18134, 28974,  2881, 13691,  2606, 25912,
           885, 11146, 30383,   131,  2544,   885, 11146, 30383, 49368,  5457,
           321,   131, 10431, 49741,  2544,  3872,   705, 48136,   131, 25384,
         37390, 49439,  1215,   179,   544,   131, 24262,  1009, 44654,   131,
           104, 13181,  3935,  4686, 49019,  5457,  2808, 39766,  2688,  1215,
           104, 13181,  3935,   131, 10799,  1215,    90,   414, 45280,  5457,
          7031,  8476,  1640, 23687,  4397,  5016, 45152, 10431,  1594,  9232,
         18134, 28974,  2881,  1594,    36,   771,  3603, 33724,   658,  1640,
          5273,   530, 15251, 11200,  1640,   176,     6,   176,   238,   359,
           605, 11146, 30383,    43, 49333,  8228,  1215, 46734,    43, 45152,
         10339,   131, 24303,   605, 11146, 30383, 49368,  5457,   112,   131,
         10431, 49741, 24501, 49019,  5457, 37062,  1640,  8573,  1215,  2444,
          3935,     6,   208, 13181,  1215,  4014, 28057,     6,  6442,  4454,
         33770,  1215,  6078,   510,  4397,  1594,    36, 24501, 49019, 45994,
          2808, 39766,  2688,  1215,   104, 13181,  3935,    43, 45152,     2,
         10339,   131, 24303, 25683,  8738, 49763, 11131,     6,   321,     6,
         49907,  1640, 11131, 48749, 11131,     4, 20338,  1215, 12368,  5457,
         17491,  1215,  2444,  3935,   131, 11131,     4, 20338,  1215, 49439,
             4,    29,  1215, 49439,  5457,    11,   594,  1215, 49439,  1640,
          3808,  1215,  2606, 10644, 12147,  4397, 11131,     4, 20338,  1215,
          3427,  5457,  1368, 38550,  1640,  6078,   510,  1215, 20275,  4397,
          1594,    36, 24501,  1640, 24501, 49019,     6,    36, 25384, 37390,
         49439, 44431,   947, 11131,     6, 49907,  1640, 11131, 35122, 45994,
           208, 13181,  3935,  1215, 46734,    43, 45152, 10339,   131, 24303,
         49051,  2060,  2723,    15,  5849,    50,     5,  2748,    21,  1367,
             6,   146,   686,     7,  3872,   705,    65,  3226,   540, 16224,
            87,    16,    11,     5,  3872,   705,  1215, 48939,    11,   645]],
       device='cuda:0')}
11/04/2022 15:53:24 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:53:40 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:53:43 - INFO - __main__ -   output tensor([[[ 55.5476, -13.2996, -18.3132,  ..., -20.4734, -19.0969, -14.6966],
         [ 37.9880, -10.0927, -13.4946,  ..., -12.9080, -13.5794, -12.8741],
         [ 22.0450,  -6.3221,  -9.0207,  ...,  -8.5076,  -8.3863,  -6.6148],
         ...,
         [  0.1561,  -0.1420,  -0.1058,  ...,  -0.1682,  -0.1710,  -0.1373],
         [  0.1561,  -0.1420,  -0.1058,  ...,  -0.1682,  -0.1710,  -0.1373],
         [  0.1561,  -0.1420,  -0.1058,  ...,  -0.1682,  -0.1710,  -0.1373]],

        [[ 56.0841, -13.5951, -18.2994,  ..., -20.6761, -19.1121, -14.8612],
         [ 38.4610, -10.2476, -13.5660,  ..., -13.1247, -13.5896, -13.0529],
         [ 22.3370,  -6.4224,  -9.1329,  ...,  -8.6580,  -8.4372,  -6.7340],
         ...,
         [  0.1561,  -0.1420,  -0.1058,  ...,  -0.1682,  -0.1710,  -0.1373],
         [  0.1561,  -0.1420,  -0.1058,  ...,  -0.1682,  -0.1710,  -0.1373],
         [  0.1561,  -0.1420,  -0.1058,  ...,  -0.1682,  -0.1710,  -0.1373]]],
       device='cuda:0', grad_fn=<AddBackward0>)
11/04/2022 15:55:57 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:56:14 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:56:17 - INFO - __main__ -   tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 15:57:19 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:57:35 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:57:38 - INFO - __main__ -   tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 15:57:38 - INFO - __main__ -   201
11/04/2022 15:57:38 - INFO - __main__ -   tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 15:59:27 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 15:59:44 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 15:59:46 - INFO - __main__ -   label: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
11/04/2022 15:59:47 - INFO - __main__ -   output: tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 15:59:47 - INFO - __main__ -   len: 201
11/04/2022 15:59:47 - INFO - __main__ -   output: tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 17:06:19 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 17:06:35 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 17:06:38 - INFO - __main__ -   content_final: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void function_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                  ', 'static void goodG2B()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '                                                                          ', '    strcpy(data, "fixedstringtest");', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '                                                  ', 'static void goodB2G()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                           ', '    fprintf(stdout, "%s\\n", data);', '}', '', 'void function_good()', '{', '    goodG2B();', '    goodB2G();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    function_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    function_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', '']
11/04/2022 17:06:38 - INFO - __main__ -   content_view: ['#include "std_testcase.h"', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")', '#define CLOSE_SOCKET closesocket', '#else', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '#ifndef OMITBAD', 'void function_bad()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', 'fprintf(stdout, data);', '}', '#endif', '#ifndef OMITGOOD', 'static void goodG2B()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'strcpy(data, "fixedstringtest");', 'fprintf(stdout, data);', '}', 'static void goodB2G()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', 'fprintf(stdout, "%s\\n", data);', '}', 'void function_good()', '{', 'goodG2B();', 'goodB2G();', '}', '#endif', '/* Below is the main(). It is only used when building this testcase on', 'its own for testing or for building a binary to use in testing binary', 'analysis tools. It is not used when compiling all the testcases as one', 'application, which is how source code analysis tools are tested. */', '#ifdef INCLUDEMAIN', 'int main(int argc, char * argv[])', '{', 'srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', 'printLine("Calling good()...");', 'function_good();', 'printLine("Finished good()");', '#endif', '#ifndef OMITBAD', 'printLine("Calling bad()...");', 'function_bad();', 'printLine("Finished bad()");', '#endif', 'return 0;', '}', '#endif']
11/04/2022 17:06:38 - INFO - __main__ -   line_error: 119
11/04/2022 17:06:38 - INFO - __main__ -   error_type: 9
11/04/2022 17:06:38 - INFO - __main__ -   label_sentent: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
11/04/2022 17:06:38 - INFO - __main__ -   label: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
11/04/2022 17:06:38 - INFO - __main__ -   output: tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 17:06:38 - INFO - __main__ -   len: 201
11/04/2022 17:06:38 - INFO - __main__ -   output: tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 17:18:34 - WARNING - __main__ -   device: cuda, n_gpu: 8
11/04/2022 17:18:47 - INFO - __main__ -   ***** Running evaluation *****
11/04/2022 17:18:49 - INFO - __main__ -   content_final: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#include "std_testcase.h"', '', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")                                      ', '#define CLOSE_SOCKET closesocket', '#else                 ', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '', '#ifndef OMITBAD', '', 'void function_bad()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '#endif              ', '', '#ifndef OMITGOOD', '', '                                                  ', 'static void goodG2B()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '                                                                          ', '    strcpy(data, "fixedstringtest");', '                                                                                                   ', '    fprintf(stdout, data);', '}', '', '                                                  ', 'static void goodB2G()', '{', '    char * data;', '    char dataBuffer[100] = "";', '    data = dataBuffer;', '    {', '#ifdef _WIN32', '        WSADATA wsaData;', '        int wsaDataInit = 0;', '#endif', '        int recvResult;', '        struct sockaddr_in service;', '        char *replace;', '        SOCKET connectSocket = INVALID_SOCKET;', '        size_t dataLen = strlen(data);', '        do', '        {', '#ifdef _WIN32', '            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '            {', '                break;', '            }', '            wsaDataInit = 1;', '#endif', '                                                                  ', '            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', '            if (connectSocket == INVALID_SOCKET)', '            {', '                break;', '            }', '            memset(&service, 0, sizeof(service));', '            service.sin_family = AF_INET;', '            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', '            service.sin_port = htons(TCP_PORT);', '            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '            {', '                break;', '            }', '            /* Abort on error or the connection was closed, make sure to recv one', '             * less char than is in the recv_buf in order to append a terminator */', '                                                             ', '            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', '            if (recvResult == SOCKET_ERROR || recvResult == 0)', '            {', '                break;', '            }', '                                        ', "            data[dataLen + recvResult / sizeof(char)] = '\\0';", '                                ', "            replace = strchr(data, '\\r');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', "            replace = strchr(data, '\\n');", '            if (replace)', '            {', "                *replace = '\\0';", '            }', '        }', '        while (0);', '        if (connectSocket != INVALID_SOCKET)', '        {', '            CLOSE_SOCKET(connectSocket);', '        }', '#ifdef _WIN32', '        if (wsaDataInit)', '        {', '            WSACleanup();', '        }', '#endif', '    }', '                                                                           ', '    fprintf(stdout, "%s\\n", data);', '}', '', 'void function_good()', '{', '    goodG2B();', '    goodB2G();', '}', '', '#endif               ', '', '/* Below is the main(). It is only used when building this testcase on', '   its own for testing or for building a binary to use in testing binary', '   analysis tools. It is not used when compiling all the testcases as one', '   application, which is how source code analysis tools are tested. */', '', '#ifdef INCLUDEMAIN', '', 'int main(int argc, char * argv[])', '{', '                         ', '    srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', '    printLine("Calling good()...");', '    function_good();', '    printLine("Finished good()");', '#endif               ', '#ifndef OMITBAD', '    printLine("Calling bad()...");', '    function_bad();', '    printLine("Finished bad()");', '#endif              ', '    return 0;', '}', '', '#endif', '']
11/04/2022 17:18:49 - INFO - __main__ -   content_view: ['#include "std_testcase.h"', '#ifndef _WIN32', '#include <wchar.h>', '#endif', '#ifdef _WIN32', '#include <winsock2.h>', '#include <windows.h>', '#include <direct.h>', '#pragma comment(lib, "ws2_32")', '#define CLOSE_SOCKET closesocket', '#else', '#include <sys/types.h>', '#include <sys/socket.h>', '#include <netinet/in.h>', '#include <arpa/inet.h>', '#include <unistd.h>', '#define INVALID_SOCKET -1', '#define SOCKET_ERROR -1', '#define CLOSE_SOCKET close', '#define SOCKET int', '#endif', '#define TCP_PORT 27015', '#define IP_ADDRESS "127.0.0.1"', '#ifndef OMITBAD', 'void function_bad()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', 'fprintf(stdout, data);', '}', '#endif', '#ifndef OMITGOOD', 'static void goodG2B()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', 'strcpy(data, "fixedstringtest");', 'fprintf(stdout, data);', '}', 'static void goodB2G()', '{', 'char * data;', 'char dataBuffer[100] = "";', 'data = dataBuffer;', '{', '#ifdef _WIN32', 'WSADATA wsaData;', 'int wsaDataInit = 0;', '#endif', 'int recvResult;', 'struct sockaddr_in service;', 'char *replace;', 'SOCKET connectSocket = INVALID_SOCKET;', 'size_t dataLen = strlen(data);', 'do', '{', '#ifdef _WIN32', 'if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)', '{', 'break;', '}', 'wsaDataInit = 1;', '#endif', 'connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);', 'if (connectSocket == INVALID_SOCKET)', '{', 'break;', '}', 'memset(&service, 0, sizeof(service));', 'service.sin_family = AF_INET;', 'service.sin_addr.s_addr = inet_addr(IP_ADDRESS);', 'service.sin_port = htons(TCP_PORT);', 'if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)', '{', 'break;', '}', '/* Abort on error or the connection was closed, make sure to recv one', '* less char than is in the recv_buf in order to append a terminator */', 'recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);', 'if (recvResult == SOCKET_ERROR || recvResult == 0)', '{', 'break;', '}', "data[dataLen + recvResult / sizeof(char)] = '\\0';", "replace = strchr(data, '\\r');", 'if (replace)', '{', "*replace = '\\0';", '}', "replace = strchr(data, '\\n');", 'if (replace)', '{', "*replace = '\\0';", '}', '}', 'while (0);', 'if (connectSocket != INVALID_SOCKET)', '{', 'CLOSE_SOCKET(connectSocket);', '}', '#ifdef _WIN32', 'if (wsaDataInit)', '{', 'WSACleanup();', '}', '#endif', '}', 'fprintf(stdout, "%s\\n", data);', '}', 'void function_good()', '{', 'goodG2B();', 'goodB2G();', '}', '#endif', '/* Below is the main(). It is only used when building this testcase on', 'its own for testing or for building a binary to use in testing binary', 'analysis tools. It is not used when compiling all the testcases as one', 'application, which is how source code analysis tools are tested. */', '#ifdef INCLUDEMAIN', 'int main(int argc, char * argv[])', '{', 'srand( (unsigned)time(NULL) );', '#ifndef OMITGOOD', 'printLine("Calling good()...");', 'function_good();', 'printLine("Finished good()");', '#endif', '#ifndef OMITBAD', 'printLine("Calling bad()...");', 'function_bad();', 'printLine("Finished bad()");', '#endif', 'return 0;', '}', '#endif']
11/04/2022 17:18:49 - INFO - __main__ -   line_error: 119
11/04/2022 17:18:49 - INFO - __main__ -   error_type: 9
11/04/2022 17:18:49 - INFO - __main__ -   label_sentent: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
11/04/2022 17:18:49 - INFO - __main__ -   label: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
11/04/2022 17:18:49 - INFO - __main__ -   output: tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 17:18:49 - INFO - __main__ -   len: 201
11/04/2022 17:18:49 - INFO - __main__ -   output: tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0], device='cuda:0')
11/04/2022 17:18:49 - INFO - __main__ -   vt: tensor([], dtype=torch.int64)
